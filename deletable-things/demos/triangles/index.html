<!doctype html>
<html>
<head>
    <script src="../../libs/three-62.min.js"></script>
    <script src="../../common/util.js"></script>
    <script src="../../common/WorldView.js"></script>
    <script src="../../common/World.js"></script>
</head>
<body>
<script>

function createGeom() {
    var geometry = new THREE.Geometry();
    var v = 1.0 / Math.sqrt(3) ;
    geometry.vertices.push(new THREE.Vector3(0, 0.5, 0));
    geometry.vertices.push(new THREE.Vector3(-v, -0.5, 0));
    geometry.vertices.push(new THREE.Vector3(v, -0.5, 0));
    geometry.faces.push(new THREE.Face3(0, 1, 2));
    return geometry;
}

function Triangle(scale, x, y, color) {
    var v = 1.0 / Math.sqrt(3) ;
    var geometry = createGeom();
    
    this.material = new THREE.MeshBasicMaterial({color: color});
    this.mesh = new THREE.Mesh(geometry, this.material);
    
    this.mesh.scale.set(scale, scale, scale);
    this.mesh.position.set(x * scale * v, y * scale, 0);
    
    if ((Math.abs(x) + Math.abs(y)) % 2 === 1) {
        this.mesh.rotation.z = Math.PI;
    }
}

var colors = [
    0x723c1a,
    0xa92f31,
    0xe52b5c,
    0x22af81,
    0x5e896e,
    0x817162,
    0xedccb1,
    0xe6e7d2,
    0xd9af50
];

function Map(nVerticalTriangles) {
    var th = 2 / nVerticalTriangles;
    
    var sx = Math.ceil((Math.sqrt(3) * nVerticalTriangles) / 2);
    var sy = Math.floor(nVerticalTriangles / 2);
    var lx = 2 * sx + 1;
    var ly = 2 * sy + 1;
    this.triangles = [];
    
    for (var x = 0; x < lx; x++) {
        var line = [];
        for (var y = 0; y < ly; y++) {
            var c = Math.floor(Math.random() * colors.length);
            var t = new Triangle(th, x - sx, y - sy, colors[c]);
            t.c = c;
            line.push(t);
        }
        this.triangles.push(line);
    }
}

function TriangleWorld() {
    World.call(this);
    this.map = new Map(21);
}

TriangleWorld.prototype = Object.create(World.prototype);
TriangleWorld.prototype.constructor = TriangleWorld;

TriangleWorld.prototype.setupWorld = function () {
    this.renderer = new THREE.WebGLRenderer({ antialiasing: true });
    this.scene = new THREE.Scene();
    
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
    this.scene.add(this.camera);
    
    var tri = this.map.triangles;
    for (var i = 0, len = tri.length; i < len; i++) {
        for (var j = 0, lenJ = tri[i].length; j < lenJ; j++) {
            this.scene.add(tri[i][j].mesh);
        }
    }
};

TriangleWorld.prototype.onTick = function () {
    for (var i = 0; i < 20; i++) {
        var tri = this.map.triangles;
        var x = Math.floor(Math.random() * tri.length);
        var y = Math.floor(Math.random() * tri[0].length);
        //var c = Math.floor(Math.random() * colors.length);
        tri[x][y].c = (tri[x][y].c + 1) % colors.length;
        tri[x][y].material.color.setHex(colors[tri[x][y].c]);
    }
};

TriangleWorld.prototype.onUpdateSize = function (width, height) {
    updateBasicOrtoCamera(this.camera, width, height);
};

var world = new TriangleWorld();
world.start();
</script>
</body>
</html>
